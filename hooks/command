#!/bin/bash
set -euo pipefail

DIR="$(cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd)"

# shellcheck source=lib/plugin.bash
. "$DIR/../lib/plugin.bash"

# Cleanup function
cleanup() {
    local exit_code=$?
    if [[ $exit_code -ne 0 ]]; then
        echo "🚨 Script exited with error code: $exit_code"
        # Clean up any temporary files or processes if needed
        # This helps prevent bash context corruption
    fi
    exit $exit_code
}

# Set up cleanup trap
trap cleanup EXIT ERR

# Main function
main() {
    local app_name
    local mode
    local rollback_mode
    
    app_name=$(plugin_read_config APP "")
    mode=$(plugin_read_config MODE "deploy")

    # Validate app name first
    if [[ -z "$app_name" ]]; then
        echo "Error: app parameter is required"
        exit 1
    fi
    
    # Validate and set rollback_mode based on mode
    if [[ "$mode" == "deploy" ]]; then
        rollback_mode=$(plugin_read_config ROLLBACK_MODE "auto")  # Default to auto for deploy
        # Validate rollback_mode for deploy
        if [[ "$rollback_mode" != "auto" && "$rollback_mode" != "manual" ]]; then
            echo "❌ Error: Invalid rollback_mode '$rollback_mode' for deploy mode. Must be 'auto' or 'manual'"
            return 1
        fi
    elif [[ "$mode" == "rollback" ]]; then
        rollback_mode=$(plugin_read_config ROLLBACK_MODE "")      # REQUIRED for rollback - no default
        if [[ -z "$rollback_mode" ]]; then
            echo "❌ Error: rollback_mode is required for rollback mode. Must be 'auto' or 'manual'"
            echo "💡 Specify rollback_mode: auto (previous version) or manual (specific target_revision)"
            return 1
        fi
        if [[ "$rollback_mode" != "auto" && "$rollback_mode" != "manual" ]]; then
            echo "❌ Error: Invalid rollback_mode '$rollback_mode' for rollback mode. Must be 'auto' or 'manual'"
            return 1
        fi
        
        # For manual rollback mode, target revision is required
        if [[ "$rollback_mode" == "manual" ]]; then
            local target_revision
            target_revision=$(plugin_read_config TARGET_REVISION "")
            if [[ -z "$target_revision" ]]; then
                echo "target_revision is required when mode is 'rollback' and rollback_mode is 'manual'"
                echo "💡 Specify the exact revision/commit hash you want to rollback to"
                return 1
            fi
        fi
    else
        echo "❌ Error: Invalid mode '$mode'. Must be 'deploy' or 'rollback'"
        return 1
    fi
    
    # Validate requirements
    validate_requirements
    
    # Setup ArgoCD authentication
    setup_argocd_auth
    
    # Validate configuration
    # Configuration validation done inline above
    
    case "$mode" in
        "deploy")
            deploy_application "$app_name" "$rollback_mode"
            ;;
        "rollback")
            # For explicit rollback mode, determine target revision
            local target_revision
            if [[ "$rollback_mode" == "manual" ]]; then
                # Use specified target revision for manual rollback
                target_revision=$(plugin_read_config TARGET_REVISION "")
                echo "🎯 Manual rollback mode: using specified target revision $target_revision"
            else
                # Use previous version from ArgoCD history for auto rollback
                target_revision=$(get_previous_deployment_revision "$app_name")
                if [[ -z "$target_revision" || "$target_revision" == "unknown" ]]; then
                    echo "No previous version available for rollback"
                    echo "💡 Use rollback_mode: manual with target_revision instead"
                    return 1
                fi
                echo "🤖 Auto rollback mode: using previous revision $target_revision"
            fi
            execute_rollback "$app_name" "$target_revision" "explicit"
            ;;
    esac
}

deploy_application() {
    local app_name="$1"
    local rollback_mode="$2"
    
    echo "🚀 Starting deployment for ArgoCD application: $app_name"
    echo "📋 Rollback mode: $rollback_mode"
    
    # Create deployment log
    local log_file
    log_file=$(create_deployment_log "$app_name" "deploy" "in_progress")
    
    # Get current working revision before deployment (actually deployed, not just synced)
    local current_revision_sha
    # Get the revision that's actually running in the cluster (from last successful operation)
    current_revision_sha=$(argocd app get "$app_name" -o json | jq -r '.status.operationState.syncResult.revision // empty' || echo "unknown")
    
    # Fallback to sync revision if operation state is not available
    if [[ -z "$current_revision_sha" || "$current_revision_sha" == "unknown" ]]; then
        current_revision_sha=$(argocd app get "$app_name" -o json | jq -r '.status.sync.revision // "unknown"')
    fi
    
    # Convert SHA to short form and find corresponding history ID
    local current_revision
    if [[ "$current_revision_sha" != "unknown" ]]; then
        local short_sha="${current_revision_sha:0:7}"
        current_revision=$(argocd app history "$app_name" | grep "$short_sha" | tail -1 | awk '{print $1}' || echo "unknown")
        echo "📍 Found current deployment: SHA $short_sha → History ID $current_revision"
    else
        current_revision="unknown"
    fi
    
    # Store pre-deployment metadata  
    set_metadata "deployment:argocd:${app_name}:previous_version" "$current_revision"
    set_metadata "deployment:argocd:${app_name}:status" "deploying"
    
    # Execute deployment
    local timeout
    timeout=$(plugin_read_config TIMEOUT "300")
    
    echo "📦 Syncing ArgoCD application..."
    {
        echo "=== Deployment Command Output ==="
        argocd app sync "$app_name" --timeout "$timeout" 2>&1
        echo "Exit code: $?"
    } >> "$log_file"
    
    echo "🔄 Executing sync command..."
    set +e  # Temporarily disable exit on error
    argocd app sync "$app_name" --timeout "$timeout"
    deploy_exit_code=$?
    set -e  # Re-enable exit on error
    
    if [[ $deploy_exit_code -eq 0 ]]; then
        new_revision=$(get_current_revision "$app_name" || echo "unknown")
        
        # Update metadata with success
        set_metadata "deployment:argocd:${app_name}:current_version" "$new_revision"
        set_metadata "deployment:argocd:${app_name}:result" "success"
        set_metadata "deployment:argocd:${app_name}:status" "deployed"
        
        # Update log with success
        echo "=== Deployment Result: SUCCESS ===" >> "$log_file"
        echo "New revision: $new_revision" >> "$log_file"
        
        # Create annotation
        create_deployment_annotation "$app_name" "$current_revision" "$new_revision" "success"
        
        # Health checks only for auto rollback mode
       if [[ "$rollback_mode" == "auto" ]]; then
            if ! monitor_application_health "$app_name"; then
                echo "🚨 Health check failed after deployment"
                previous_revision=$(get_metadata "deployment:argocd:${app_name}:previous_version" || echo "")
                handle_deployment_failure "$app_name" "$rollback_mode" "$previous_revision" "$log_file" "health_check_failed"
                return  # Let handle_deployment_failure manage the exit
            fi
        else
            echo "📋 Manual rollback mode - checking health once without retry"
            # Do a single quick health check for manual mode
            if ! check_application_health "$app_name"; then
                echo "❌ Application is unhealthy - manual intervention required"
                echo "🚨 Health check failed after deployment"
                previous_revision=$(get_metadata "deployment:argocd:${app_name}:previous_version" || echo "")
                handle_deployment_failure "$app_name" "$rollback_mode" "$previous_revision" "$log_file" "health_check_failed"
                return  # Let handle_deployment_failure manage the exit
            fi
        fi
        
        # Collect logs and upload artifacts if enabled
        handle_log_collection_and_artifacts "$app_name" "$log_file"
        
        echo "✅ Deployment successful"
        echo "   Previous: $current_revision"
        echo "   Current:  $new_revision"
    else
        echo "🚨 Deployment sync failed with exit code: $deploy_exit_code"
        previous_revision=$(get_metadata "deployment:argocd:${app_name}:previous_version" || echo "")
        handle_deployment_failure "$app_name" "$rollback_mode" "$previous_revision" "$log_file" "deployment_failed"
    fi
}

handle_deployment_failure() {
    local app_name="$1"
    local rollback_mode="$2"
    local previous_revision="$3"
    local log_file="$4"
    local failure_reason="$5"
    
    # Update metadata with failure
    set_metadata "deployment:argocd:${app_name}:result" "failed"
    set_metadata "deployment:argocd:${app_name}:status" "failed"
    set_metadata "deployment:argocd:${app_name}:failure_reason" "$failure_reason"
    
    # Update log with failure
    echo "=== Deployment Result: FAILED - $failure_reason ===" >> "$log_file"
    
    # Create failure annotation
    create_deployment_annotation "$app_name" "$previous_revision" "$previous_revision" "failed"
    
    # Handle rollback based on mode
    if [[ "$rollback_mode" == "auto" ]]; then
        echo "🤖 Auto rollback mode: initiating automatic rollback..."
        if [[ -z "$previous_revision" || "$previous_revision" == "unknown" ]]; then
            echo "No previous version available for rollback"
            handle_log_collection_and_artifacts "$app_name" "$log_file"
            exit 1
        fi
        execute_rollback "$app_name" "$previous_revision" "automatic"
    elif [[ "$rollback_mode" == "manual" ]]; then
        echo "📋 Manual rollback mode: injecting block step for user decision..."
        inject_rollback_decision_block "$app_name" "$previous_revision"
        
        # Collect logs and upload artifacts for manual review
        handle_log_collection_and_artifacts "$app_name" "$log_file"
        
        # Send notification about failure
        send_rollback_notification "$app_name" "current" "$previous_revision" "$failure_reason"
        
        echo "⏸️  Pipeline paused for manual rollback decision"
        # Exit successfully - the block step will handle the rollback decision
        exit 0
    elif [[ "$rollback_mode" == "none" ]]; then
        echo "⚠️ None rollback mode: accepting deployment failure without rollback..."
        handle_log_collection_and_artifacts "$app_name" "$log_file"
        
        # Send notification about failure
        send_rollback_notification "$app_name" "current" "$previous_revision" "$failure_reason"
        
        echo "❌ Deployment failed - rollback disabled by configuration"
        exit 1
    else
        echo "❌ Unknown rollback mode: $rollback_mode"
        handle_log_collection_and_artifacts "$app_name" "$log_file"
        exit 1
    fi
}

execute_rollback() {
    local app_name="$1"
    local rollback_revision="$2"
    local rollback_type="$3"  # "automatic" or "explicit"
    
    echo "🔄 Starting $rollback_type rollback for ArgoCD application: $app_name"
    
    # Create rollback log
    local rollback_log_file
    rollback_log_file=$(create_deployment_log "$app_name" "rollback" "in_progress")
    
    # Get current (failed) revision
    local current_revision
    current_revision=$(get_current_revision "$app_name" || echo "unknown")
    
    if [[ -z "$rollback_revision" || "$rollback_revision" == "unknown" ]]; then
        echo "❌ Error: No rollback revision available"
        echo "=== Rollback Result: FAILED - No rollback revision ===" >> "$rollback_log_file"
        handle_log_collection_and_artifacts "$app_name" "$rollback_log_file"
        exit 1
    fi
    
    echo "⏪ Rolling back from $current_revision to $rollback_revision..."
    
    # Store rollback metadata
    set_metadata "deployment:argocd:${app_name}:rollback_from" "$current_revision"
    set_metadata "deployment:argocd:${app_name}:rollback_to" "$rollback_revision"
    set_metadata "deployment:argocd:${app_name}:status" "rolling_back"
    
    # Execute rollback using helper function
    local timeout
    timeout=$(plugin_read_config TIMEOUT "300")
    
    # Check if auto-sync is enabled (need to disable it temporarily for proper rollback)
    sync_policy=$(argocd app get "$app_name" -o json | jq -r '.spec.syncPolicy.automated // empty' || echo "")
    
    rollback_success=false
    auto_sync_was_enabled=false
    
    if [[ -n "$sync_policy" ]]; then
        echo "🔄 Auto-sync detected - temporarily disabling for proper rollback"
        auto_sync_was_enabled=true
        
        # Step 1: Disable auto-sync
        echo "🚫 Disabling auto-sync..."
        {
            echo "=== Disabling Auto-Sync ==="
            echo "Command: argocd app set $app_name --sync-policy manual"
            argocd app set "$app_name" --sync-policy manual 2>&1
            echo "Exit code: $?"
        } >> "$rollback_log_file"
        
        set +e
        disable_output=$(argocd app set "$app_name" --sync-policy manual 2>&1)
        disable_exit_code=$?
        set -e
        
        if [[ $disable_exit_code -ne 0 ]]; then
            echo "❌ Failed to disable auto-sync with exit code: $disable_exit_code"
            echo "ArgoCD disable error output:"
            echo "$disable_output"
            echo "⚠️  Proceeding with rollback anyway..."
            auto_sync_was_enabled=false
        else
            echo "✅ Auto-sync disabled successfully"
        fi
    fi
    
    # Step 2: Perform rollback using helper function
    echo "⏪ Performing rollback to revision: $rollback_revision"
    {
        echo "=== Rollback Command Output ==="
        echo "Looking up history ID for revision: $rollback_revision"
        argocd app history "$app_name" | head -10
    } >> "$rollback_log_file"
    
    # Use helper function to look up deployment history ID and execute rollback
    set +e
    history_id=$(lookup_deployment_history_id "$app_name" "$rollback_revision")
    lookup_exit_code=$?
    set -e
    
    if [[ $lookup_exit_code -eq 0 ]]; then
        set +e
        rollback_output=$(argocd app rollback "$app_name" "$history_id" --timeout "$timeout" 2>&1)
        rollback_exit_code=$?
        set -e
        
        if [[ $rollback_exit_code -eq 0 ]]; then
            echo "✅ Rollback command succeeded"
            
            # Wait for rollback to complete (only for auto rollback)
            if [[ "$rollback_type" == "automatic" ]]; then
                echo "⏳ Waiting for rollback to complete..."
                set +e
                wait_output=$(argocd app wait "$app_name" --health --timeout "$timeout" 2>&1)
                wait_exit_code=$?
                set -e
                
                if [[ $wait_exit_code -eq 0 ]]; then
                    echo "✅ Rollback completed successfully"
                    rollback_success=true
                else
                    echo "❌ Rollback wait failed with exit code: $wait_exit_code"
                    echo "ArgoCD wait error output: $wait_output"
                    rollback_success=false
                fi
            else
                # For explicit rollbacks, don't wait - user initiated it deliberately
                echo "✅ Explicit rollback command completed"
                rollback_success=true
            fi
        else
            echo "❌ ArgoCD rollback command failed with exit code: $rollback_exit_code"
            echo "ArgoCD rollback error output: $rollback_output"
            rollback_success=false
        fi
    else
        echo "❌ Failed to lookup deployment history ID for revision: $rollback_revision"
        rollback_success=false
    fi
    
    # Step 3: Re-enable auto-sync if it was originally enabled
    if [[ "$auto_sync_was_enabled" == "true" ]]; then
        echo "🔄 Re-enabling auto-sync..."
        {
            echo "=== Re-enabling Auto-Sync ==="
            echo "Command: argocd app set $app_name --sync-policy automated"
            argocd app set "$app_name" --sync-policy automated 2>&1
            echo "Exit code: $?"
        } >> "$rollback_log_file"
        
        set +e
        reenable_output=$(argocd app set "$app_name" --sync-policy automated 2>&1)
        reenable_exit_code=$?
        set -e
        
        if [[ $reenable_exit_code -eq 0 ]]; then
            echo "✅ Auto-sync re-enabled successfully"
        else
            echo "⚠️  Failed to re-enable auto-sync (exit code: $reenable_exit_code)"
            echo "ArgoCD re-enable error output:"
            echo "$reenable_output"
        fi
    fi
    
    # Handle rollback result
    if [[ "$rollback_success" == "true" ]]; then
        # Update metadata with success
        set_metadata "deployment:argocd:${app_name}:current_version" "$rollback_revision"
        set_metadata "deployment:argocd:${app_name}:result" "rollback_success"
        set_metadata "deployment:argocd:${app_name}:status" "rolled_back"
        
        # Update log with success
        echo "=== Rollback Result: SUCCESS ===" >> "$rollback_log_file"
        echo "Rolled back to revision: $rollback_revision" >> "$rollback_log_file"
        
        create_rollback_annotation "$app_name" "$current_revision" "$rollback_revision"
        
        # Collect logs and upload artifacts
        handle_log_collection_and_artifacts "$app_name" "$rollback_log_file"
        
        # Send success notification
        send_rollback_notification "$app_name" "$current_revision" "$rollback_revision" "rollback_success"
        
        echo "✅ Rollback successful"
        echo "   Failed:     $current_revision"
        echo "   Rolled to:  $rollback_revision"
    else
        # Update metadata with failure
        set_metadata "deployment:argocd:${app_name}:result" "rollback_failed"
        set_metadata "deployment:argocd:${app_name}:status" "rollback_failed"
        
        # Update log with failure
        echo "=== Rollback Result: FAILED ===" >> "$rollback_log_file"
        
        # Collect logs and upload artifacts even on failure
        handle_log_collection_and_artifacts "$app_name" "$rollback_log_file"
        
        # Send failure notification
        send_rollback_notification "$app_name" "$current_revision" "$rollback_revision" "rollback_failed"
        
        echo "❌ Rollback failed"
        exit 1
    fi
}

# Health monitoring functions (only used for deploy + auto rollback)
monitor_application_health() {
    local app_name="$1"
    
    health_check_interval=$(plugin_read_config HEALTH_CHECK_INTERVAL "30")
    health_check_timeout=$(plugin_read_config HEALTH_CHECK_TIMEOUT "300")
    
    echo "🏥 Starting health monitoring for $app_name (auto rollback mode)..."
    
    local start_time
    start_time=$(date +%s)
    local end_time
    end_time=$((start_time + health_check_timeout))
    
    while [[ $(date +%s) -lt $end_time ]]; do
        check_application_health "$app_name"
        health_exit_code=$?
        
        if [[ $health_exit_code -eq 0 ]]; then
            echo "✅ Application health check passed"
            return 0
        elif [[ $health_exit_code -eq 2 ]]; then
            echo "💥 Application is degraded - failing fast instead of waiting for timeout"
            return 2
        fi
        
        echo "⏳ Waiting ${health_check_interval}s before next health check..."
        sleep "$health_check_interval"
    done
    
    echo "❌ Health check timeout reached (application never became healthy)"
    return 1
}

check_application_health() {
    local app_name="$1"
    
    # Get application status via ArgoCD API
    local app_status
    app_status=$(argocd app get "$app_name" --output json 2>/dev/null | jq -r '.status.health.status // "Unknown"')
    
    case "$app_status" in
        "Healthy")
            return 0
            ;;
        "Progressing")
            echo "🔄 Application is progressing..."
            return 1
            ;;
        "Degraded")
            echo "❌ Application is degraded - triggering immediate rollback"
            return 2  # Special exit code for immediate failure
            ;;
        "Suspended")
            echo "⏸️  Application is suspended"
            return 1
            ;;
        *)
            echo "❓ Unknown application status: $app_status"
            return 1
            ;;
    esac
}

# Notification functions
send_rollback_notification() {
    local app_name="$1"
    local from_revision="$2"
    local to_revision="$3"
    local reason="$4"
    
    slack_channel=$(plugin_read_config NOTIFICATIONS_SLACK_CHANNEL "")
    webhook_url=$(plugin_read_config NOTIFICATIONS_WEBHOOK_URL "")
    pagerduty_key=$(plugin_read_config NOTIFICATIONS_PAGERDUTY_INTEGRATION_KEY "")
    
    # Send Slack notification using Buildkite's native integration
    if [[ -n "$slack_channel" ]]; then
        echo "📢 Sending Slack notification to $slack_channel..."
        
        # Inject notification step using Buildkite's native Slack integration
        local notification_pipeline
        notification_pipeline=$(cat <<-EOF
steps:
  - label: ":slack: Rollback Notification"
    command: "echo 'Rollback notification sent'"
    notify:
      - slack:
          channels:
            - "$slack_channel"
          message: |
            🚨 *ArgoCD Rollback Alert*
            
            *Application:* \`$app_name\`
            *Reason:* $reason
            *From Revision:* \`$from_revision\`
            *To Revision:* \`$to_revision\`
            *Build:* <${BUILDKITE_BUILD_URL:-#}|#${BUILDKITE_BUILD_NUMBER:-unknown}>
            *Pipeline:* \`${BUILDKITE_PIPELINE_SLUG:-unknown}\`
            *Branch:* \`${BUILDKITE_BRANCH:-unknown}\`
EOF
        )
        
        echo "$notification_pipeline" | buildkite-agent pipeline upload || echo "⚠️  Failed to inject Slack notification step"
        echo "✅ Slack notification step injected for $slack_channel"
    fi
    
    # Send webhook notification
    if [[ -n "$webhook_url" ]]; then
        echo "🔗 Sending webhook notification..."
        curl -X POST -H 'Content-Type: application/json' \
            --data "{\"app\":\"$app_name\",\"reason\":\"$reason\",\"from\":\"$from_revision\",\"to\":\"$to_revision\"}" \
            "$webhook_url" || echo "⚠️  Failed to send webhook notification"
    fi
    
    # Send PagerDuty alert
    if [[ -n "$pagerduty_key" ]]; then
        echo "📟 Sending PagerDuty alert..."
        local payload="{
            \"routing_key\": \"$pagerduty_key\",
            \"event_action\": \"trigger\",
            \"payload\": {
                \"summary\": \"ArgoCD Rollback: $app_name\",
                \"source\": \"buildkite\",
                \"severity\": \"warning\",
                \"custom_details\": {
                    \"app\": \"$app_name\",
                    \"reason\": \"$reason\",
                    \"from_revision\": \"$from_revision\",
                    \"to_revision\": \"$to_revision\"
                }
            }
        }"
        
        curl -X POST -H 'Content-Type: application/json' \
            --data "$payload" \
            'https://events.pagerduty.com/v2/enqueue' || echo "⚠️  Failed to send PagerDuty alert"
    fi
}

create_deployment_annotation() {
    local app_name="$1"
    local previous_version="$2"
    local current_version="$3"
    local deployment_result="$4"
    
    local annotation
    case "$deployment_result" in
        "success")
            annotation="✅ **ArgoCD Deployment Successful**

**Application:** \`$app_name\`  
**Previous Version:** \`$previous_version\`  
**Current Version:** \`$current_version\`  
**Status:** \`$deployment_result\`  
**Timestamp:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
            ;;
        "failed")
            annotation="❌ **ArgoCD Deployment Failed**

**Application:** \`$app_name\`  
**Status:** \`$deployment_result\`  
**Timestamp:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
            ;;
    esac
    
    local style
    if [[ "$deployment_result" == "success" ]]; then
        style="success"
    else
        style="error"
    fi
    
    buildkite-agent annotate "$annotation" --style "$style" --context "argocd-deployment-$app_name" || true
}

create_rollback_annotation() {
    local app_name="$1"
    local from_revision="$2"
    local to_revision="$3"
    
    local annotation="🔄 **ArgoCD Rollback**

**Application:** \`$app_name\`  
**Failed Revision:** \`$from_revision\`  
**Rolled Back To:** \`$to_revision\`  
**Build:** [${BUILDKITE_BUILD_NUMBER:-unknown}](${BUILDKITE_BUILD_URL:-#})  
**Pipeline:** \`${BUILDKITE_PIPELINE_SLUG:-unknown}\`  
**Branch:** \`${BUILDKITE_BRANCH:-unknown}\`"
    
    buildkite-agent annotate "$annotation" --style "warning" --context "argocd-rollback-$app_name" || true
}

handle_log_collection_and_artifacts() {
    local app_name="$1"
    local deployment_log_file="$2"
    
    collect_logs=$(plugin_read_config COLLECT_LOGS "false")
    upload_artifacts_enabled=$(plugin_read_config UPLOAD_ARTIFACTS "false")
    log_lines=$(plugin_read_config LOG_LINES "1000")
    
    if [[ "$collect_logs" == "true" ]]; then
        echo "📋 Log collection enabled, gathering ArgoCD application logs..."
        local log_dir
        log_dir=$(collect_app_logs "$app_name" "$log_lines")
        
        # Copy deployment log to the log directory
        if [[ -f "$deployment_log_file" ]]; then
            cp "$deployment_log_file" "$log_dir/"
        fi
        
        if [[ "$upload_artifacts_enabled" == "true" ]]; then
            upload_artifacts "$log_dir" "$app_name"
        else
            echo "📤 Artifact upload disabled, logs collected in: $log_dir"
        fi
    else
        echo "📋 Log collection disabled"
        
        # Still upload the deployment log if artifacts are enabled
        if [[ "$upload_artifacts_enabled" == "true" && -f "$deployment_log_file" ]]; then
            echo "📤 Uploading deployment log..."
            buildkite-agent artifact upload "$deployment_log_file" || true
        fi
    fi
}

# Sanitize strings for YAML to prevent parsing errors
sanitize_yaml_string() {
    local input="$1"
    # Remove emojis, special characters, and non-ASCII characters
    # Keep only alphanumeric, spaces, hyphens, underscores, parentheses, and periods
    echo "$input" | sed 's/[^a-zA-Z0-9 ()._-]//g' | tr -d '\r\n'
}

inject_rollback_decision_block() {
    local app_name="$1"
    
    echo "📋 Injecting rollback decision block step for $app_name..."
    
    # Create a temporary file for the pipeline YAML
    local pipeline_file
    pipeline_file=$(mktemp)
    
    # Generate the pipeline YAML directly (no complex string replacement)
    cat > "$pipeline_file" << EOF
steps:
  - block: "🚨 Deployment Failed - Choose Action"
    prompt: |
      **Deployment failed for application: $app_name**
      
      Please choose your next action:
      
      **Option 1: Rollback (Recommended)**
      - Automatically rollback to the last stable deployment
      - Safer option for production environments
      
      **Option 2: Accept Failure**
      - Keep current failed state for debugging
      - Manual investigation required
    fields:
      - select: "Action"
        key: "rollback_action" 
        hint: "What would you like to do?"
        required: true
        default: "rollback"
        options:
          - label: "🔄 Rollback to Previous Stable Version"
            value: "rollback"
          - label: "⚠️ Accept Failure (No Rollback)"
            value: "accept"
  
  - label: "🎯 Execute Decision"
    command: |
      set -euo pipefail
      
      echo "--- 📋 Processing rollback decision for $app_name"
      
      # Get user decision from block step
      decision=\$(buildkite-agent step get "rollback_action")
      echo "User decision: \$decision"
      
      if [[ "\$decision" == "accept" ]]; then
        echo "--- ⚠️ User chose to accept deployment failure"
        
        # Create annotation for accepted failure
        buildkite-agent annotate "**Deployment Failure Accepted**

**Application:** \`$app_name\`  
**Action:** User chose to accept failure and skip rollback  
**Status:** Failed deployment left in place for debugging  
**Timestamp:** \$(date -u '+%Y-%m-%d %H:%M:%S UTC')

*Manual investigation and cleanup may be required.*" \\
          --style "warning" \\
          --context "accept-failure-$app_name" || true
          
        # Upload logs and artifacts for debugging
        echo "📤 Collecting logs and artifacts for debugging..."
        
        # Get the original deployment log if it exists
        deployment_log=\$(buildkite-agent meta-data get "deployment:argocd:$app_name:log_file" 2>/dev/null || echo "")
        if [[ -n "\$deployment_log" && -f "\$deployment_log" ]]; then
          echo "📋 Uploading deployment log: \$deployment_log"
          buildkite-agent artifact upload "\$deployment_log" || true
        fi
        
        # Collect ArgoCD application status for debugging
        echo "📊 Collecting ArgoCD application status..."
        argocd app get "$app_name" --output yaml > "argocd-app-status-$app_name.yaml" || true
        buildkite-agent artifact upload "argocd-app-status-$app_name.yaml" || true
        
        echo "✅ Failure accepted - artifacts uploaded for debugging"
        exit 0
      fi
      
      # User chose rollback - find previous stable deployment
      echo "--- 🔄 User chose rollback - finding previous stable deployment"
      
      # Get previous deployment from ArgoCD history
      echo "🔍 Searching ArgoCD deployment history..."
      if ! argocd app history "$app_name" > /tmp/history.txt 2>/dev/null; then
        echo "❌ Failed to get ArgoCD deployment history"
        exit 1
      fi
      
      # Find the previous deployment (skip header and current)
      previous_revision=\$(awk 'NR > 1 && NR <= 2 { next } NR == 3 { print \$1; exit }' /tmp/history.txt 2>/dev/null || echo "")
      
      if [[ -z "\$previous_revision" ]]; then
        echo "❌ No previous deployment found for rollback"
        
        buildkite-agent annotate "**Rollback Not Available**

**Application:** \`$app_name\`  
**Error:** No previous successful deployment found  
**Action Required:** Manual investigation needed  
**Timestamp:** \$(date -u '+%Y-%m-%d %H:%M:%S UTC')" \\
          --style "error" \\
          --context "no-rollback-$app_name" || true
        
        exit 1
      fi
      
      echo "📍 Found previous deployment: History ID \$previous_revision"
      
      # Execute the rollback
      echo "--- ⏪ Executing rollback to history ID \$previous_revision"
      
      timeout=\$(buildkite-agent meta-data get "deployment:argocd:$app_name:timeout" 2>/dev/null || echo "300")
      
      if argocd app rollback "$app_name" "\$previous_revision" --timeout "\$timeout"; then
        echo "✅ Rollback command executed successfully"
        
        # Create success annotation  
        buildkite-agent annotate "**Rollback Successful**

**Application:** \`$app_name\`  
**Rolled back to:** History ID \`\$previous_revision\`  
**Status:** Rollback completed successfully  
**Timestamp:** \$(date -u '+%Y-%m-%d %H:%M:%S UTC')

*The application has been restored to the previous stable version.*" \\
          --style "success" \\
          --context "rollback-success-$app_name" || true
          
        # Update metadata
        buildkite-agent meta-data set "deployment:argocd:$app_name:result" "rollback_success"
        buildkite-agent meta-data set "deployment:argocd:$app_name:status" "rolled_back"
        
        echo "🎉 Rollback completed successfully"
        exit 0
      else
        echo "❌ Rollback command failed"
        
        buildkite-agent annotate "**Rollback Failed**

**Application:** \`$app_name\`  
**Target:** History ID \`\$previous_revision\`  
**Error:** ArgoCD rollback command failed  
**Action Required:** Manual investigation needed  
**Timestamp:** \$(date -u '+%Y-%m-%d %H:%M:%S UTC')" \\
          --style "error" \\
          --context "rollback-failed-$app_name" || true
        
        # Update metadata  
        buildkite-agent meta-data set "deployment:argocd:$app_name:result" "rollback_failed"
        buildkite-agent meta-data set "deployment:argocd:$app_name:status" "rollback_failed"
        
        exit 1
      fi
    depends_on: ~
EOF
    
    echo "📤 Uploading rollback decision pipeline..."
    if buildkite-agent pipeline upload "$pipeline_file"; then
        echo "✅ Successfully injected rollback decision block step"
        rm -f "$pipeline_file"
        return 0
    else
        echo "❌ Failed to inject rollback decision block - pipeline upload failed"
        echo "Pipeline YAML that failed to upload:"
        cat "$pipeline_file" >&2
        rm -f "$pipeline_file"
        return 1
    fi
}

# Execute main function
main "$@"