#!/bin/bash

set -euo pipefail

DIR="$(cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd)"

# shellcheck source=lib/plugin.bash
. "$DIR/../lib/plugin.bash"

# Cleanup function
cleanup() {
    local exit_code=$?
    if [[ $exit_code -ne 0 ]]; then
        echo "üö® Script exited with error code: $exit_code"
        # Clean up any temporary files or processes if needed
        # This helps prevent bash context corruption
    fi
    exit $exit_code
}

# Set up cleanup trap
trap cleanup EXIT ERR

# Main function
main() {
    local app_name
    local mode
    local rollback_mode
    
    app_name=$(plugin_read_config APP "")
    mode=$(plugin_read_config MODE "deploy")
    
    # Set rollback_mode based on mode
    if [[ "$mode" == "deploy" ]]; then
        rollback_mode=$(plugin_read_config ROLLBACK_MODE "auto")  # Default to auto for deploy
        # Validate rollback_mode for deploy
        if [[ "$rollback_mode" != "auto" && "$rollback_mode" != "manual" && "$rollback_mode" != "none" ]]; then
            echo "‚ùå Error: Invalid rollback_mode '$rollback_mode'. Must be 'auto', 'manual', or 'none'"
            return 1
        fi
    elif [[ "$mode" == "rollback" ]]; then
        rollback_mode=$(plugin_read_config ROLLBACK_MODE "")      # Required for rollback
        if [[ -z "$rollback_mode" ]]; then
            echo "‚ùå Error: rollback_mode is required when mode is 'rollback'. Must be 'auto' or 'manual'"
            return 1
        fi
        if [[ "$rollback_mode" != "auto" && "$rollback_mode" != "manual" ]]; then
            echo "‚ùå Error: Invalid rollback_mode '$rollback_mode' for rollback mode. Must be 'auto' or 'manual'"
            return 1
        fi
    else
        echo "‚ùå Error: Invalid mode '$mode'. Must be 'deploy' or 'rollback'"
        return 1
    fi
    
    # Validate requirements
    validate_requirements
    
    # Setup ArgoCD authentication
    setup_argocd_auth
    
    # Validate configuration
    validate_config "$app_name" "$mode" "$rollback_mode"
    
    case "$mode" in
        "deploy")
            deploy_application "$app_name"
            ;;
        "rollback")
            # For explicit rollback mode, get previous version from metadata
            local previous_revision
            previous_revision=$(get_metadata "deployment:argocd:${app_name}:previous_version" || echo "")
            execute_rollback "$app_name" "$previous_revision" "" "$rollback_mode"
            ;;
    esac
}

deploy_application() {
    local app_name="$1"
    
    echo "üöÄ Starting deployment for ArgoCD application: $app_name"
    
    # Create deployment log
    local log_file
    log_file=$(create_deployment_log "$app_name" "deploy" "in_progress")
    
    # Get current working revision before deployment (actually deployed, not just synced)
    local current_revision_sha
    # Get the revision that's actually running in the cluster (from last successful operation)
    current_revision_sha=$(argocd app get "$app_name" -o json | jq -r '.status.operationState.syncResult.revision // empty' || echo "unknown")
    
    # Fallback to sync revision if operation state is not available
    if [[ -z "$current_revision_sha" || "$current_revision_sha" == "unknown" ]]; then
        current_revision_sha=$(argocd app get "$app_name" -o json | jq -r '.status.sync.revision // "unknown"')
    fi
    
    # Convert SHA to short form and find corresponding history ID
    local current_revision
    if [[ "$current_revision_sha" != "unknown" ]]; then
        local short_sha="${current_revision_sha:0:7}"
        current_revision=$(argocd app history "$app_name" | grep "$short_sha" | tail -1 | awk '{print $1}' || echo "unknown")
        echo "üìç Found current deployment: SHA $short_sha ‚Üí History ID $current_revision"
    else
        current_revision="unknown"
    fi
    
    # Store pre-deployment metadata  
    set_metadata "deployment:argocd:${app_name}:previous_version" "$current_revision"
    set_metadata "deployment:argocd:${app_name}:status" "deploying"
    
    # Execute deployment
    local timeout
    timeout=$(plugin_read_config TIMEOUT "300")
    
    echo "üì¶ Syncing ArgoCD application..."
    {
        echo "=== Deployment Command Output ==="
        argocd app sync "$app_name" --timeout "$timeout" 2>&1
        echo "Exit code: $?"
    } >> "$log_file"
    
    echo "üîÑ Executing sync command..."
    set +e  # Temporarily disable exit on error
    argocd app sync "$app_name" --timeout "$timeout"
    deploy_exit_code=$?
    set -e  # Re-enable exit on error
    
    if [[ $deploy_exit_code -eq 0 ]]; then
        new_revision=$(get_current_revision "$app_name" || echo "unknown")
        
        # Update metadata with success
        set_metadata "deployment:argocd:${app_name}:current_version" "$new_revision"
        set_metadata "deployment:argocd:${app_name}:result" "success"
        set_metadata "deployment:argocd:${app_name}:status" "deployed"
        
        # Update log with success
        echo "=== Deployment Result: SUCCESS ===" >> "$log_file"
        echo "New revision: $new_revision" >> "$log_file"
        
        # Create annotation
        create_deployment_annotation "$app_name" "$current_revision" "$new_revision" "success"
        
        # Check application health based on rollback_mode
        if ! monitor_application_health "$app_name" "$rollback_mode"; then
            echo "üö® Health check failed after deployment"
            previous_revision=$(get_metadata "deployment:argocd:${app_name}:previous_version" || echo "")
            handle_deployment_failure "$app_name" "$rollback_mode" "$previous_revision" "$log_file" "health_check_failed"
            # Let handle_deployment_failure manage the exit - don't return here
        fi
        
        # Collect logs and upload artifacts if enabled
        handle_log_collection_and_artifacts "$app_name" "$log_file"
        
        echo "‚úÖ Deployment successful"
        echo "   Previous: $current_revision"
        echo "   Current:  $new_revision"
    else
        echo "üö® Deployment sync failed with exit code: $deploy_exit_code"
        previous_revision=$(get_metadata "deployment:argocd:${app_name}:previous_version" || echo "")
        handle_deployment_failure "$app_name" "auto" "$previous_revision" "$log_file" "deployment_failed"
    fi
}

handle_deployment_failure() {
    local app_name="$1"
    local rollback_mode="$2"
    local previous_revision="$3"
    local log_file="$4"
    local failure_reason="$5"
    
    # Update metadata with failure
    set_metadata "deployment:argocd:${app_name}:result" "failed"
    set_metadata "deployment:argocd:${app_name}:status" "failed"
    set_metadata "deployment:argocd:${app_name}:failure_reason" "$failure_reason"
    
    # Update log with failure
    echo "=== Deployment Result: FAILED - $failure_reason ===" >> "$log_file"
    
    # Create failure annotation
    create_deployment_annotation "$app_name" "$previous_revision" "$previous_revision" "failed"
    
    # Handle rollback based on mode
    if [[ "$rollback_mode" == "auto" ]]; then
        echo "ü§ñ Auto rollback mode: initiating automatic rollback..."
        execute_rollback "$app_name" "$previous_revision" "$log_file" "auto"
    elif [[ "$rollback_mode" == "manual" ]]; then
        echo "üìã Manual rollback mode: injecting input step for user decision..."
        inject_rollback_decision_block "$app_name" "$previous_revision"
        
        # Collect logs and upload artifacts for manual review
        handle_log_collection_and_artifacts "$app_name" "$log_file"
        
        # Send notification about failure
        send_rollback_notification "$app_name" "current" "$previous_revision" "$failure_reason"
        
        echo "‚è∏Ô∏è  Pipeline paused for manual rollback decision"
    elif [[ "$rollback_mode" == "none" ]]; then
        echo "üö´ No rollback mode: accepting deployment failure"
        
        # Collect logs and upload artifacts for debugging
        handle_log_collection_and_artifacts "$app_name" "$log_file"
        
        # Send notification about failure (no rollback)
        send_rollback_notification "$app_name" "current" "none" "$failure_reason"
        
        echo "‚ùå Deployment failed - no rollback configured"
        return 1
    else
        echo "‚ùå Unknown rollback mode: $rollback_mode"
        handle_log_collection_and_artifacts "$app_name" "$log_file"
        return 1
    fi
}

execute_rollback() {
    local app_name="$1"
    local rollback_revision="$2"
    local log_file="$3"
    local rollback_type="$4"
    
    echo "üîÑ Starting $rollback_type rollback for ArgoCD application: $app_name"
    
    # Create rollback log
    local rollback_log_file
    rollback_log_file=$(create_deployment_log "$app_name" "rollback" "in_progress")
    
    # Get current (failed) revision
    local current_revision
    current_revision=$(get_current_revision "$app_name" || echo "unknown")
    
    if [[ -z "$rollback_revision" ]]; then
        echo "‚ùå Error: No previous version available for rollback"
        echo "=== Rollback Result: FAILED - No previous version ===" >> "$rollback_log_file"
        handle_log_collection_and_artifacts "$app_name" "$rollback_log_file"
        return 1
    fi
    
    echo "‚è™ Rolling back from $current_revision to $rollback_revision..."
    
    # Store rollback metadata
    set_metadata "deployment:argocd:${app_name}:rollback_from" "$current_revision"
    set_metadata "deployment:argocd:${app_name}:rollback_to" "$rollback_revision"
    set_metadata "deployment:argocd:${app_name}:status" "rolling_back"
    
    # Execute rollback - always use rollback command, handle auto-sync appropriately
    local timeout
    timeout=$(plugin_read_config TIMEOUT "300")
    
    # Check if auto-sync is enabled (need to disable it temporarily for proper rollback)
    sync_policy=$(argocd app get "$app_name" -o json | jq -r '.spec.syncPolicy.automated // empty' || echo "")
    
    # Always use rollback command - never sync (sync would just re-deploy broken code)
    rollback_success=false
    auto_sync_was_enabled=false
    
    if [[ -n "$sync_policy" ]]; then
        echo "üîÑ Auto-sync detected - temporarily disabling for proper rollback"
        auto_sync_was_enabled=true
        
        # Step 1: Disable auto-sync using native CLI
        echo "üö´ Disabling auto-sync..."
        {
            echo "=== Disabling Auto-Sync ==="
            echo "Command: argocd app set $app_name --sync-policy manual"
            argocd app set "$app_name" --sync-policy manual 2>&1
            echo "Exit code: $?"
        } >> "$rollback_log_file"
        
        set +e
        disable_output=$(argocd app set "$app_name" --sync-policy manual 2>&1)
        disable_exit_code=$?
        set -e
        
        if [[ $disable_exit_code -ne 0 ]]; then
            echo "‚ùå Failed to disable auto-sync with exit code: $disable_exit_code"
            echo "ArgoCD disable error output:"
            echo "$disable_output"
            echo "‚ö†Ô∏è  Proceeding with rollback anyway (skipping auto-sync disable)..."
            auto_sync_was_enabled=false  # Don't try to re-enable if we couldn't disable
        else
            echo "‚úÖ Auto-sync disabled successfully"
        fi
        
        # Step 2: Perform rollback to specific revision
        echo "‚è™ Performing rollback to revision: $rollback_revision"
        {
            echo "=== Rollback Command Output ==="
            echo "Looking up history ID for revision: $rollback_revision"
            argocd app history "$app_name" | head -10
        } >> "$rollback_log_file"
        
        # Look up the ArgoCD deployment history ID for the git revision
        echo "üîç Looking up deployment history ID for revision: $rollback_revision"
        history_id=$(argocd app history "$app_name" | grep "${rollback_revision:0:7}" | tail -1 | awk '{print $1}')
        
        if [[ -z "$history_id" ]]; then
            echo "‚ùå Could not find deployment history ID for revision: $rollback_revision"
            rollback_success=false
            rollback_output="No deployment history found for revision ${rollback_revision:0:7}"
            rollback_exit_code=1
        else
            echo "üìç Found deployment history ID: $history_id for revision: $rollback_revision"
            set +e
            rollback_output=$(argocd app rollback "$app_name" "$history_id" --timeout "$timeout" 2>&1)
            rollback_exit_code=$?
            set -e
        fi
        
        if [[ $rollback_exit_code -eq 0 ]]; then
            echo "‚úÖ Rollback command succeeded"
            
            # Step 3: Wait for rollback to complete
            echo "‚è≥ Waiting for rollback to complete..."
            set +e
            wait_output=$(argocd app wait "$app_name" --health --timeout "$timeout" 2>&1)
            wait_exit_code=$?
            set -e
            
            if [[ $wait_exit_code -eq 0 ]]; then
                echo "‚úÖ Rollback completed successfully"
                rollback_success=true
            else
                echo "‚ùå Rollback wait failed with exit code: $wait_exit_code"
                echo "ArgoCD wait error output: $wait_output"
                rollback_success=false
            fi
        else
            echo "‚ùå ArgoCD rollback command failed with exit code: $rollback_exit_code"
            echo "ArgoCD rollback error output: $rollback_output"
            rollback_success=false
        fi
        
        # Step 4: Re-enable auto-sync if it was originally enabled
        if [[ "$auto_sync_was_enabled" == "true" ]]; then
            echo "üîÑ Re-enabling auto-sync..."
            {
                echo "=== Re-enabling Auto-Sync ==="
                echo "Command: argocd app set $app_name --sync-policy automated"
                argocd app set "$app_name" --sync-policy automated 2>&1
                echo "Exit code: $?"
            } >> "$rollback_log_file"
            
            set +e
            reenable_output=$(argocd app set "$app_name" --sync-policy automated 2>&1)
            reenable_exit_code=$?
            set -e
            
            if [[ $reenable_exit_code -eq 0 ]]; then
                echo "‚úÖ Auto-sync re-enabled successfully"
            else
                echo "‚ö†Ô∏è  Failed to re-enable auto-sync (exit code: $reenable_exit_code)"
                echo "ArgoCD re-enable error output:"
                echo "$reenable_output"
            fi
        fi
    else
        echo "üîÑ Auto-sync not enabled - using direct rollback command"
        {
            echo "=== Rollback Command Output ==="
            echo "Looking up history ID for revision: $rollback_revision"
            argocd app history "$app_name" | head -10
        } >> "$rollback_log_file"
        
        # Look up the ArgoCD deployment history ID for the git revision
        echo "üîç Looking up deployment history ID for revision: $rollback_revision"
        history_id=$(argocd app history "$app_name" | grep "${rollback_revision:0:7}" | tail -1 | awk '{print $1}')
        
        if [[ -z "$history_id" ]]; then
            echo "‚ùå Could not find deployment history ID for revision: $rollback_revision"
            rollback_success=false
            rollback_output="No deployment history found for revision ${rollback_revision:0:7}"
            rollback_exit_code=1
        else
            echo "üìç Found deployment history ID: $history_id for revision: $rollback_revision"
            set +e
            rollback_output=$(argocd app rollback "$app_name" "$history_id" --timeout "$timeout" 2>&1)
            rollback_exit_code=$?
            set -e
        fi
        
        if [[ $rollback_exit_code -eq 0 ]]; then
            rollback_success=true
        else
            echo "‚ùå ArgoCD rollback command failed with exit code: $rollback_exit_code"
            echo "ArgoCD rollback error output: $rollback_output"
            rollback_success=false
        fi
    fi
    
    if [[ "$rollback_success" == "true" ]]; then
        # Update metadata with success
        set_metadata "deployment:argocd:${app_name}:current_version" "$rollback_revision"
        set_metadata "deployment:argocd:${app_name}:result" "rollback_success"
        set_metadata "deployment:argocd:${app_name}:status" "rolled_back"
        
        # Update log with success
        echo "=== Rollback Result: SUCCESS ===" >> "$rollback_log_file"
        echo "Rolled back to revision: $rollback_revision" >> "$rollback_log_file"
        
        create_rollback_annotation "$app_name" "$current_revision" "$rollback_revision"
        
        # Collect logs and upload artifacts
        handle_log_collection_and_artifacts "$app_name" "$rollback_log_file"
        
        # Send success notification
        send_rollback_notification "$app_name" "$current_revision" "$rollback_revision" "automatic_recovery"
        
        echo "‚úÖ Rollback successful"
        echo "   Failed:     $current_revision"
        echo "   Rolled to:  $rollback_revision"
    else
        # Update metadata with failure
        set_metadata "deployment:argocd:${app_name}:result" "rollback_failed"
        set_metadata "deployment:argocd:${app_name}:status" "rollback_failed"
        
        # Update log with failure
        echo "=== Rollback Result: FAILED ===" >> "$rollback_log_file"
        
        # Collect logs and upload artifacts even on failure
        handle_log_collection_and_artifacts "$app_name" "$rollback_log_file"
        
        # Send failure notification
        send_rollback_notification "$app_name" "$current_revision" "$rollback_revision" "rollback_failed"
        
        echo "‚ùå Rollback failed"
        return 1
    fi
}

# Health monitoring functions
monitor_application_health() {
    local app_name="$1"
    local rollback_mode="$2"
    
    health_check_interval=$(plugin_read_config HEALTH_CHECK_INTERVAL "30")
    health_check_timeout=$(plugin_read_config HEALTH_CHECK_TIMEOUT "300")
    
    # Health check behavior is driven by rollback_mode
    if [[ "$rollback_mode" == "manual" ]]; then
        echo "üìã Manual rollback mode - checking health once without retry"
        check_application_health "$app_name"
        local health_status=$?
        if [[ $health_status != 0 ]]; then
            echo "‚ùå Application is unhealthy - manual intervention required"
            return 1  # Return failure to trigger manual rollback workflow
        else
            echo "‚úÖ Application is healthy"
            return 0
        fi
    elif [[ "$rollback_mode" == "none" ]]; then
        echo "üö´ No rollback mode - checking health once, will accept failure"
        check_application_health "$app_name"
        local health_status=$?
        if [[ $health_status != 0 ]]; then
            echo "‚ùå Application is unhealthy - no rollback configured"
            return 1  # Return failure but no rollback will be attempted
        else
            echo "‚úÖ Application is healthy"
            return 0
        fi
    elif [[ "$rollback_mode" == "auto" ]]; then
        echo "ü§ñ Auto rollback mode - continuous health monitoring enabled"
    else
        echo "‚ùå Invalid rollback_mode: $rollback_mode"
        return 1
    fi
    
    echo "üè• Starting health monitoring for $app_name..."
    
    local start_time
    start_time=$(date +%s)
    local end_time
    end_time=$((start_time + health_check_timeout))
    
    while [[ $(date +%s) -lt $end_time ]]; do
        check_application_health "$app_name"
        health_exit_code=$?
        
        if [[ $health_exit_code -eq 0 ]]; then
            echo "‚úÖ Application health check passed"
            return 0
        elif [[ $health_exit_code -eq 2 ]]; then
            echo "üí• Application is degraded - failing fast instead of waiting for timeout"
            return 2
        fi
        
        echo "‚è≥ Waiting ${health_check_interval}s before next health check..."
        sleep "$health_check_interval"
    done
    
    echo "‚ùå Health check timeout reached (application never became healthy)"
    return 1
}

check_application_health() {
    local app_name="$1"
    
    # Get application status via ArgoCD API
    local app_status
    app_status=$(argocd app get "$app_name" --output json 2>/dev/null | jq -r '.status.health.status // "Unknown"')
    
    case "$app_status" in
        "Healthy")
            return 0
            ;;
        "Progressing")
            echo "üîÑ Application is progressing..."
            return 1
            ;;
        "Degraded")
            echo "‚ùå Application is degraded - triggering immediate rollback"
            return 2  # Special exit code for immediate failure
            ;;
        "Suspended")
            echo "‚è∏Ô∏è  Application is suspended"
            return 1
            ;;
        *)
            echo "‚ùì Unknown application status: $app_status"
            return 1
            ;;
    esac
}

# Notification functions
send_rollback_notification() {
    local app_name="$1"
    local from_revision="$2"
    local to_revision="$3"
    local reason="$4"
    
    slack_channel=$(plugin_read_config NOTIFICATIONS_SLACK_CHANNEL "")
    webhook_url=$(plugin_read_config NOTIFICATIONS_WEBHOOK_URL "")
    pagerduty_key=$(plugin_read_config NOTIFICATIONS_PAGERDUTY_INTEGRATION_KEY "")
    
    # Send Slack notification using Buildkite's native integration
    if [[ -n "$slack_channel" ]]; then
        echo "üì¢ Sending Slack notification to $slack_channel..."
        
        # Inject notification step using Buildkite's native Slack integration
        local notification_pipeline
        notification_pipeline=$(cat <<-EOF
steps:
  - label: ":slack: Rollback Notification"
    command: "echo 'Rollback notification sent'"
    notify:
      - slack:
          channels:
            - "$slack_channel"
          message: |
            üö® *ArgoCD Rollback Alert*
            
            *Application:* \`$app_name\`
            *Reason:* $reason
            *From Revision:* \`$from_revision\`
            *To Revision:* \`$to_revision\`
            *Build:* <${BUILDKITE_BUILD_URL:-#}|#${BUILDKITE_BUILD_NUMBER:-unknown}>
            *Pipeline:* \`${BUILDKITE_PIPELINE_SLUG:-unknown}\`
            *Branch:* \`${BUILDKITE_BRANCH:-unknown}\`
EOF
        )
        
        echo "$notification_pipeline" | buildkite-agent pipeline upload || echo "‚ö†Ô∏è  Failed to inject Slack notification step"
        echo "‚úÖ Slack notification step injected for $slack_channel"
    fi
    
    # Send webhook notification
    if [[ -n "$webhook_url" ]]; then
        echo "üîó Sending webhook notification..."
        curl -X POST -H 'Content-Type: application/json' \
            --data "{\"app\":\"$app_name\",\"reason\":\"$reason\",\"from\":\"$from_revision\",\"to\":\"$to_revision\"}" \
            "$webhook_url" || echo "‚ö†Ô∏è  Failed to send webhook notification"
    fi
    
    # Send PagerDuty alert
    if [[ -n "$pagerduty_key" ]]; then
        echo "üìü Sending PagerDuty alert..."
        local payload="{
            \"routing_key\": \"$pagerduty_key\",
            \"event_action\": \"trigger\",
            \"payload\": {
                \"summary\": \"ArgoCD Rollback: $app_name\",
                \"source\": \"buildkite\",
                \"severity\": \"warning\",
                \"custom_details\": {
                    \"app\": \"$app_name\",
                    \"reason\": \"$reason\",
                    \"from_revision\": \"$from_revision\",
                    \"to_revision\": \"$to_revision\"
                }
            }
        }"
        
        curl -X POST -H 'Content-Type: application/json' \
            --data "$payload" \
            'https://events.pagerduty.com/v2/enqueue' || echo "‚ö†Ô∏è  Failed to send PagerDuty alert"
    fi
}

create_deployment_annotation() {
    local app_name="$1"
    local previous_version="$2"
    local current_version="$3"
    local deployment_result="$4"
    
    local annotation
    case "$deployment_result" in
        "success")
            annotation="‚úÖ **ArgoCD Deployment Successful**

**Application:** \`$app_name\`  
**Previous Version:** \`$previous_version\`  
**Current Version:** \`$current_version\`  
**Status:** \`$deployment_result\`  
**Timestamp:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
            ;;
        "failed")
            annotation="‚ùå **ArgoCD Deployment Failed**

**Application:** \`$app_name\`  
**Status:** \`$deployment_result\`  
**Timestamp:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
            ;;
    esac
    
    local style
    if [[ "$deployment_result" == "success" ]]; then
        style="success"
    else
        style="error"
    fi
    
    buildkite-agent annotate "$annotation" --style "$style" --context "argocd-deployment-$app_name" || true
}

create_rollback_annotation() {
    local app_name="$1"
    local from_revision="$2"
    local to_revision="$3"
    
    local annotation="üîÑ **ArgoCD Rollback**

**Application:** \`$app_name\`  
**Failed Revision:** \`$from_revision\`  
**Rolled Back To:** \`$to_revision\`  
**Build:** [${BUILDKITE_BUILD_NUMBER:-unknown}](${BUILDKITE_BUILD_URL:-#})  
**Pipeline:** \`${BUILDKITE_PIPELINE_SLUG:-unknown}\`  
**Branch:** \`${BUILDKITE_BRANCH:-unknown}\`"
    
    buildkite-agent annotate "$annotation" --style "warning" --context "argocd-rollback-$app_name" || true
}

handle_log_collection_and_artifacts() {
    local app_name="$1"
    local deployment_log_file="$2"
    
    collect_logs=$(plugin_read_config COLLECT_LOGS "false")
    upload_artifacts_enabled=$(plugin_read_config UPLOAD_ARTIFACTS "false")
    log_lines=$(plugin_read_config LOG_LINES "1000")
    
    if [[ "$collect_logs" == "true" ]]; then
        echo "üìã Log collection enabled, gathering ArgoCD application logs..."
        local log_dir
        log_dir=$(collect_app_logs "$app_name" "$log_lines")
        
        # Copy deployment log to the log directory
        if [[ -f "$deployment_log_file" ]]; then
            cp "$deployment_log_file" "$log_dir/"
        fi
        
        if [[ "$upload_artifacts_enabled" == "true" ]]; then
            upload_artifacts "$log_dir" "$app_name"
        else
            echo "üì§ Artifact upload disabled, logs collected in: $log_dir"
        fi
    else
        echo "üìã Log collection disabled"
        
        # Still upload the deployment log if artifacts are enabled
        if [[ "$upload_artifacts_enabled" == "true" && -f "$deployment_log_file" ]]; then
            echo "üì§ Uploading deployment log..."
            buildkite-agent artifact upload "$deployment_log_file" || true
        fi
    fi
}

inject_rollback_decision_block() {
    local app_name="$1"
    local previous_revision="$2"
    
    echo "üìã Injecting rollback decision block step..."
    echo "üîç Fetching recent deployment history..."
    
    # Get revision options with simplified approach
    echo "üìã Fetching revision options..."
    local revision_options=""
    
    # Try to get multiple revisions, fallback to previous revision only
    if argocd app history "$app_name" > /tmp/argocd_history.txt 2>/dev/null; then
        echo "‚úÖ Got ArgoCD history, processing revisions..."
        local count=0
        while IFS= read -r line && [[ $count -lt 5 ]]; do
            if [[ -n "$line" && "$line" != "ID"* ]]; then
                local rev_id
                rev_id=$(echo "$line" | awk '{print $1}')
                local rev_hash
                rev_hash=$(echo "$line" | awk '{print $7}' | tr -d '()')
                if [[ -n "$rev_hash" && "$rev_hash" != "unknown" ]]; then
                    local short_hash=${rev_hash:0:7}
                    revision_options+="          - label: \"Revision $rev_id ($short_hash)\"
            value: \"$rev_hash\"
"
                    ((count++))
                fi
            fi
        done < /tmp/argocd_history.txt
        rm -f /tmp/argocd_history.txt
    fi
    
    # Fallback to previous revision if no options found
    if [[ -z "$revision_options" ]]; then
        echo "üìã Using fallback: previous revision only"
        revision_options="          - label: \"Previous Version ($previous_revision)\"
            value: \"$previous_revision\"
"
    fi
    
    local pipeline_yaml
    pipeline_yaml=$(cat <<-EOF
steps:
  - input: ":warning: Deployment Failed - Rollback Decision"
    prompt: "Deployment failed for $app_name. Choose your action:"
    fields:
      - select: "Action"
        key: "rollback_action"
        options:
          - label: "Keep Current (Failed) Deployment"
            value: "keep"
          - label: "Rollback to Selected Version"
            value: "rollback"
      - select: "Rollback Target (if rollback selected)"
        key: "rollback_revision"
        options:
$revision_options
    
  - label: ":arrow_backward: Execute Manual Rollback"
    command: |
      # Check user's decision
      if [[ "\$BUILDKITE_TRIGGERED_FROM_BUILD_PIPELINE_SLUG" ]]; then
        rollback_action=\$(buildkite-agent meta-data get "rollback_action" 2>/dev/null || echo "keep")
        rollback_revision=\$(buildkite-agent meta-data get "rollback_revision" 2>/dev/null || echo "$previous_revision")
      else
        rollback_action="rollback"
        rollback_revision="$previous_revision"
      fi
      
      if [[ "\$rollback_action" == "keep" ]]; then
        echo "üö´ User chose to keep current (failed) deployment"
        echo "‚ö†Ô∏è  Application remains in failed state for investigation"
        exit 0
      else
        echo "üîÑ User chose to rollback to: \$rollback_revision"
        echo "üöÄ Executing manual rollback for $app_name to \$rollback_revision..."
        
        # Set environment for rollback execution
        export BUILDKITE_PLUGIN_ARGOCD_DEPLOYMENT_APP="$app_name"
        export BUILDKITE_PLUGIN_ARGOCD_DEPLOYMENT_ROLLBACK_MODE="manual"
        
        # Execute rollback to selected revision
        $(dirname "\$0")/execute_manual_rollback.sh "$app_name" "\$rollback_revision"
      fi
    depends_on:
      - step: ":warning: Deployment Failed - Rollback Decision"
        allow_failure: false
    if: 'build.meta_data.get("rollback_action") == "rollback"'
    
  - label: ":x: Keep Failed Deployment"
    command: |
      echo "User chose to keep the failed deployment for $app_name"
      echo "Manual intervention may be required"
    depends_on:
      - step: ":warning: Deployment Failed - Rollback Decision"
        allow_failure: false
    if: 'build.meta_data.get("rollback_action") == "keep"'
EOF
        )
        
        echo "üì§ Uploading rollback decision pipeline..."
        if echo "$pipeline_yaml" | buildkite-agent pipeline upload; then
            echo "‚úÖ Successfully injected rollback decision input step"
        else
            echo "‚ùå Failed to inject rollback decision block - pipeline upload failed"
            echo "üìã Pipeline YAML that failed to upload:"
            echo "$pipeline_yaml"
            return 1
        fi
}

# Execute main function
main "$@"
