#!/bin/bash
set -euo pipefail

DIR="$(cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd)"

# shellcheck source=lib/plugin.bash
. "$DIR/../lib/plugin.bash"

# Cleanup function
cleanup() {
    local exit_code=$?
    if [[ $exit_code -ne 0 ]]; then
        echo "üö® Script exited with error code: $exit_code"
        # Clean up any temporary files or processes if needed
        # This helps prevent bash context corruption
    fi
    exit $exit_code
}

# Set up cleanup trap
trap cleanup EXIT ERR

# Main function
main() {
    local app_name
    local mode
    local rollback_mode
    
    app_name=$(plugin_read_config APP "")
    mode=$(plugin_read_config MODE "deploy")

    # Validate app name first
    if [[ -z "$app_name" ]]; then
        echo "Error: app parameter is required"
        exit 1
    fi
    
    # Validate and set rollback_mode based on mode
    if [[ "$mode" == "deploy" ]]; then
        rollback_mode=$(plugin_read_config ROLLBACK_MODE "auto")  # Default to auto for deploy
        # Validate rollback_mode for deploy
        if [[ "$rollback_mode" != "auto" && "$rollback_mode" != "manual" ]]; then
            echo "‚ùå Error: Invalid rollback_mode '$rollback_mode' for deploy mode. Must be 'auto' or 'manual'"
            return 1
        fi
    elif [[ "$mode" == "rollback" ]]; then
        rollback_mode=$(plugin_read_config ROLLBACK_MODE "")      # REQUIRED for rollback - no default
        if [[ -z "$rollback_mode" ]]; then
            echo "‚ùå Error: rollback_mode is required for rollback mode. Must be 'auto' or 'manual'"
            echo "üí° Specify rollback_mode: auto (previous version) or manual (specific target_revision)"
            return 1
        fi
        if [[ "$rollback_mode" != "auto" && "$rollback_mode" != "manual" ]]; then
            echo "‚ùå Error: Invalid rollback_mode '$rollback_mode' for rollback mode. Must be 'auto' or 'manual'"
            return 1
        fi
        
        # For manual rollback mode, target revision is required
        if [[ "$rollback_mode" == "manual" ]]; then
            local target_revision
            target_revision=$(plugin_read_config TARGET_REVISION "")
            if [[ -z "$target_revision" ]]; then
                echo "target_revision is required when mode is 'rollback' and rollback_mode is 'manual'"
                echo "üí° Specify either:"
                echo "   - ArgoCD History ID (e.g., '5')"
                echo "   - Git commit SHA (e.g., 'abc123def456')"
                return 1
            fi
        fi
    else
        echo "‚ùå Error: Invalid mode '$mode'. Must be 'deploy' or 'rollback'"
        return 1
    fi
    
    # Validate requirements
    validate_requirements
    
    # Setup ArgoCD authentication
    setup_argocd_auth
    
    # Note: Configuration validation completed inline above (lines 32-73)
    
    case "$mode" in
        "deploy")
            deploy_application "$app_name" "$rollback_mode"
            ;;
        "rollback")
            # For explicit rollback mode, determine target revision
            local target_revision
            if [[ "$rollback_mode" == "manual" ]]; then
                # Use specified target revision for manual rollback
                target_revision=$(plugin_read_config TARGET_REVISION "")
                echo "üéØ Manual rollback mode: using specified target revision $target_revision"
            else
                # Use previous version from ArgoCD history for auto rollback
                target_revision=$(get_previous_deployment_revision "$app_name")
                if [[ -z "$target_revision" || "$target_revision" == "unknown" ]]; then
                    echo "No previous version available for rollback"
                    echo "üí° Use rollback_mode: manual with target_revision instead"
                    return 1
                fi
                echo "ü§ñ Auto rollback mode: using previous revision $target_revision"
            fi
            execute_rollback "$app_name" "$target_revision" "explicit"
            ;;
    esac
}


deploy_application() {
    local app_name="$1"
    local rollback_mode="$2"
    
    echo "üöÄ Starting deployment for ArgoCD application: $app_name"
    echo "üìã Rollback mode: $rollback_mode"
    
    # Create deployment log
    local log_file
    log_file=$(create_deployment_log "$app_name" "deploy" "in_progress")
    
    # Get current working revision before deployment (actually deployed, not just synced)
    local current_revision
    current_revision=$(get_current_stable_deployment "$app_name")
    
    # Store pre-deployment metadata  
    set_metadata "deployment:argocd:${app_name}:previous_version" "$current_revision"
    set_metadata "deployment:argocd:${app_name}:status" "deploying"
    
    # Execute deployment
    local timeout
    timeout=$(plugin_read_config TIMEOUT "300")
    
    echo "üì¶ Syncing ArgoCD application..."
    {
        echo "=== Deployment Command Output ==="
        argocd app sync "$app_name" --timeout "$timeout" 2>&1
        echo "Exit code: $?"
    } >> "$log_file"
    
    echo "üîÑ Executing sync command..."
    set +e  # Temporarily disable exit on error
    argocd app sync "$app_name" --timeout "$timeout"
    deploy_exit_code=$?
    set -e  # Re-enable exit on error
    
    if [[ $deploy_exit_code -eq 0 ]]; then
        new_revision=$(get_current_revision "$app_name" || echo "unknown")
        
        # Update metadata with success
        set_metadata "deployment:argocd:${app_name}:current_version" "$new_revision"
        set_metadata "deployment:argocd:${app_name}:result" "success"
        set_metadata "deployment:argocd:${app_name}:status" "deployed"
        
        # Update log with success
        echo "=== Deployment Result: SUCCESS ===" >> "$log_file"
        echo "New revision: $new_revision" >> "$log_file"
        
        # Create annotation
        create_deployment_annotation "$app_name" "$current_revision" "$new_revision" "success"
        
        # Health checks only for auto rollback mode
       if [[ "$rollback_mode" == "auto" ]]; then
            if ! monitor_application_health "$app_name"; then
                echo "üö® Health check failed after deployment"
                previous_revision=$(get_metadata "deployment:argocd:${app_name}:previous_version" || echo "")
                handle_deployment_failure "$app_name" "$rollback_mode" "$previous_revision" "$log_file" "health_check_failed"
                return  # Let handle_deployment_failure manage the exit
            fi
        else
            echo "üìã Manual rollback mode - checking health once without retry"
            # Do a single quick health check for manual mode
            if ! check_application_health "$app_name"; then
                echo "‚ùå Application is unhealthy - manual intervention required"
                echo "üö® Health check failed after deployment"
                previous_revision=$(get_metadata "deployment:argocd:${app_name}:previous_version" || echo "")
                handle_deployment_failure "$app_name" "$rollback_mode" "$previous_revision" "$log_file" "health_check_failed"
                return  # Let handle_deployment_failure manage the exit
            fi
        fi
        
        # Collect logs and upload artifacts if enabled
        handle_log_collection_and_artifacts "$app_name" "$log_file"
        
        echo "‚úÖ Deployment successful"
        echo "   Previous: $current_revision"
        echo "   Current:  $new_revision"
    else
        echo "üö® Deployment sync failed with exit code: $deploy_exit_code"
        previous_revision=$(get_metadata "deployment:argocd:${app_name}:previous_version" || echo "")
        handle_deployment_failure "$app_name" "$rollback_mode" "$previous_revision" "$log_file" "deployment_failed"
    fi
}

handle_deployment_failure() {
    local app_name="$1"
    local rollback_mode="$2"
    local previous_revision="$3"
    local log_file="$4"
    local failure_reason="$5"
    
    # Update metadata with failure
    set_metadata "deployment:argocd:${app_name}:result" "failed"
    set_metadata "deployment:argocd:${app_name}:status" "failed"
    set_metadata "deployment:argocd:${app_name}:failure_reason" "$failure_reason"
    
    # Update log with failure
    echo "=== Deployment Result: FAILED - $failure_reason ===" >> "$log_file"
    
    # Create failure annotation
    create_deployment_annotation "$app_name" "$previous_revision" "$previous_revision" "failed"
    
    # Handle rollback based on mode
    if [[ "$rollback_mode" == "auto" ]]; then
        echo "ü§ñ Auto rollback mode: initiating automatic rollback..."
        if [[ -z "$previous_revision" || "$previous_revision" == "unknown" ]]; then
            echo "No previous version available for rollback"
            handle_log_collection_and_artifacts "$app_name" "$log_file"
            exit 1
        fi
        execute_rollback "$app_name" "$previous_revision" "automatic"
    else
        # rollback_mode == "manual"
        echo "üìã Manual rollback mode: injecting block step for user decision..."
        inject_rollback_decision_block "$app_name" "$previous_revision"
        
        # Collect logs and upload artifacts for manual review
        handle_log_collection_and_artifacts "$app_name" "$log_file"
        
        # Send notification about failure
        send_rollback_notification "$app_name" "current" "$previous_revision" "$failure_reason"
        
        echo "‚è∏Ô∏è  Pipeline paused for manual rollback decision"
        # Exit successfully - the block step will handle the rollback decision
        exit 0
    fi
}

execute_rollback() {
    local app_name="$1"
    local rollback_revision="$2"
    local rollback_type="$3"  # "automatic" or "explicit"
    
    echo "üîÑ Starting $rollback_type rollback for ArgoCD application: $app_name"
    
    # Create rollback log
    local rollback_log_file
    rollback_log_file=$(create_deployment_log "$app_name" "rollback" "in_progress")
    
    # Get current (failed) revision
    local current_revision
    current_revision=$(get_current_revision "$app_name" || echo "unknown")
    
    if [[ -z "$rollback_revision" || "$rollback_revision" == "unknown" ]]; then
        echo "‚ùå Error: No rollback revision available"
        echo "=== Rollback Result: FAILED - No rollback revision ===" >> "$rollback_log_file"
        handle_log_collection_and_artifacts "$app_name" "$rollback_log_file"
        exit 1
    fi
    
    echo "‚è™ Rolling back from $current_revision to $rollback_revision..."
    
    # Store rollback metadata
    set_metadata "deployment:argocd:${app_name}:rollback_from" "$current_revision"
    set_metadata "deployment:argocd:${app_name}:rollback_to" "$rollback_revision"
    set_metadata "deployment:argocd:${app_name}:status" "rolling_back"
    
    # Execute rollback using helper function
    local timeout
    timeout=$(plugin_read_config TIMEOUT "300")
    
    # Check if auto-sync is enabled (need to disable it temporarily for proper rollback)
    sync_policy=$(argocd app get "$app_name" -o json | jq -r '.spec.syncPolicy.automated // empty' || echo "")
    
    rollback_success=false
    auto_sync_was_enabled=false
    
    if [[ -n "$sync_policy" ]]; then
        echo "üîÑ Auto-sync detected - temporarily disabling for proper rollback"
        auto_sync_was_enabled=true
        
        # Step 1: Disable auto-sync
        echo "üö´ Disabling auto-sync..."
        {
            echo "=== Disabling Auto-Sync ==="
            echo "Command: argocd app set $app_name --sync-policy manual"
            argocd app set "$app_name" --sync-policy manual 2>&1
            echo "Exit code: $?"
        } >> "$rollback_log_file"
        
        set +e
        disable_output=$(argocd app set "$app_name" --sync-policy manual 2>&1)
        disable_exit_code=$?
        set -e
        
        if [[ $disable_exit_code -ne 0 ]]; then
            echo "‚ùå Failed to disable auto-sync with exit code: $disable_exit_code"
            echo "ArgoCD disable error output:"
            echo "$disable_output"
            echo "‚ö†Ô∏è  Proceeding with rollback anyway..."
            auto_sync_was_enabled=false
        else
            echo "‚úÖ Auto-sync disabled successfully"
        fi
    fi
    
    # Step 2: Perform rollback using helper function
    echo "‚è™ Performing rollback to revision: $rollback_revision"
    {
        echo "=== Rollback Command Output ==="
        echo "Looking up history ID for revision: $rollback_revision"
        argocd app history "$app_name" | head -10
    } >> "$rollback_log_file"
    
    # Use helper function to look up deployment history ID and execute rollback
    set +e
    history_id=$(lookup_deployment_history_id "$app_name" "$rollback_revision")
    lookup_exit_code=$?
    set -e
    
    if [[ $lookup_exit_code -eq 0 ]]; then
        set +e
        rollback_output=$(argocd app rollback "$app_name" "$history_id" --timeout "$timeout" 2>&1)
        rollback_exit_code=$?
        set -e
        
        if [[ $rollback_exit_code -eq 0 ]]; then
            echo "‚úÖ Rollback command succeeded"
            
            # Wait for rollback to complete (only for auto rollback)
            if [[ "$rollback_type" == "automatic" ]]; then
                echo "‚è≥ Waiting for rollback to complete..."
                set +e
                wait_output=$(argocd app wait "$app_name" --health --timeout "$timeout" 2>&1)
                wait_exit_code=$?
                set -e
                
                if [[ $wait_exit_code -eq 0 ]]; then
                    echo "‚úÖ Rollback completed successfully"
                    rollback_success=true
                else
                    echo "‚ùå Rollback wait failed with exit code: $wait_exit_code"
                    echo "ArgoCD wait error output: $wait_output"
                    rollback_success=false
                fi
            else
                # For explicit rollbacks, don't wait - user initiated it deliberately
                echo "‚úÖ Explicit rollback command completed"
                rollback_success=true
            fi
        else
            echo "‚ùå ArgoCD rollback command failed with exit code: $rollback_exit_code"
            echo "ArgoCD rollback error output: $rollback_output"
            rollback_success=false
        fi
    else
        echo "‚ùå Failed to lookup deployment history ID for revision: $rollback_revision"
        rollback_success=false
    fi
    
    # Step 3: Re-enable auto-sync if it was originally enabled
    if [[ "$auto_sync_was_enabled" == "true" ]]; then
        echo "üîÑ Re-enabling auto-sync..."
        {
            echo "=== Re-enabling Auto-Sync ==="
            echo "Command: argocd app set $app_name --sync-policy automated"
            argocd app set "$app_name" --sync-policy automated 2>&1
            echo "Exit code: $?"
        } >> "$rollback_log_file"
        
        set +e
        reenable_output=$(argocd app set "$app_name" --sync-policy automated 2>&1)
        reenable_exit_code=$?
        set -e
        
        if [[ $reenable_exit_code -eq 0 ]]; then
            echo "‚úÖ Auto-sync re-enabled successfully"
        else
            echo "‚ö†Ô∏è  Failed to re-enable auto-sync (exit code: $reenable_exit_code)"
            echo "ArgoCD re-enable error output:"
            echo "$reenable_output"
        fi
    fi
    
    # Handle rollback result
    if [[ "$rollback_success" == "true" ]]; then
        # Update metadata with success
        set_metadata "deployment:argocd:${app_name}:current_version" "$rollback_revision"
        set_metadata "deployment:argocd:${app_name}:result" "rollback_success"
        set_metadata "deployment:argocd:${app_name}:status" "rolled_back"
        
        # Update log with success
        echo "=== Rollback Result: SUCCESS ===" >> "$rollback_log_file"
        echo "Rolled back to revision: $rollback_revision" >> "$rollback_log_file"
        
        create_rollback_annotation "$app_name" "$current_revision" "$rollback_revision"
        
        # Collect logs and upload artifacts
        handle_log_collection_and_artifacts "$app_name" "$rollback_log_file"
        
        # Send success notification
        send_rollback_notification "$app_name" "$current_revision" "$rollback_revision" "rollback_success"
        
        echo "‚úÖ Rollback successful"
        echo "   Failed:     $current_revision"
        echo "   Rolled to:  $rollback_revision"
    else
        # Update metadata with failure
        set_metadata "deployment:argocd:${app_name}:result" "rollback_failed"
        set_metadata "deployment:argocd:${app_name}:status" "rollback_failed"
        
        # Update log with failure
        echo "=== Rollback Result: FAILED ===" >> "$rollback_log_file"
        
        # Collect logs and upload artifacts even on failure
        handle_log_collection_and_artifacts "$app_name" "$rollback_log_file"
        
        # Send failure notification
        send_rollback_notification "$app_name" "$current_revision" "$rollback_revision" "rollback_failed"
        
        echo "‚ùå Rollback failed"
        exit 1
    fi
}

# Health monitoring functions (only used for deploy + auto rollback)
monitor_application_health() {
    local app_name="$1"
    
    health_check_interval=$(plugin_read_config HEALTH_CHECK_INTERVAL "30")
    health_check_timeout=$(plugin_read_config HEALTH_CHECK_TIMEOUT "300")
    
    echo "üè• Starting health monitoring for $app_name (auto rollback mode)..."
    
    local start_time
    start_time=$(date +%s)
    local end_time
    end_time=$((start_time + health_check_timeout))
    
    while [[ $(date +%s) -lt $end_time ]]; do
        check_application_health "$app_name"
        health_exit_code=$?
        
        if [[ $health_exit_code -eq 0 ]]; then
            echo "‚úÖ Application health check passed"
            return 0
        elif [[ $health_exit_code -eq 2 ]]; then
            echo "üí• Application is degraded - failing fast instead of waiting for timeout"
            return 2
        fi
        
        echo "‚è≥ Waiting ${health_check_interval}s before next health check..."
        sleep "$health_check_interval"
    done
    
    echo "‚ùå Health check timeout reached (application never became healthy)"
    return 1
}

check_application_health() {
    local app_name="$1"
    
    # Get application status via ArgoCD API
    local app_status
    app_status=$(argocd app get "$app_name" --output json 2>/dev/null | jq -r '.status.health.status // "Unknown"')
    
    case "$app_status" in
        "Healthy")
            return 0
            ;;
        "Progressing")
            echo "üîÑ Application is progressing..."
            return 1
            ;;
        "Degraded")
            echo "‚ùå Application is degraded - triggering immediate rollback"
            return 2  # Special exit code for immediate failure
            ;;
        "Suspended")
            echo "‚è∏Ô∏è  Application is suspended"
            return 1
            ;;
        *)
            echo "‚ùì Unknown application status: $app_status"
            return 1
            ;;
    esac
}

# Notification functions
send_rollback_notification() {
    local app_name="$1"
    local from_revision="$2"
    local to_revision="$3"
    local reason="$4"
    
    local slack_channel
    slack_channel=$(plugin_read_config NOTIFICATIONS_SLACK_CHANNEL "")
    
    # Send Slack notification using Buildkite's native integration
    if [[ -n "$slack_channel" ]]; then
        echo "üì¢ Sending Slack notification to $slack_channel..."
        
        # Inject notification step using Buildkite's native Slack integration
        local notification_pipeline
        notification_pipeline=$(cat <<-EOF
steps:
  - label: ":slack: Rollback Notification"
    command: "echo 'Rollback notification sent'"
    notify:
      - slack:
          channels:
            - "$slack_channel"
          message: |
            üö® *ArgoCD Rollback Alert*
            
            *Application:* \`$app_name\`
            *Reason:* $reason
            *From Revision:* \`$from_revision\`
            *To Revision:* \`$to_revision\`
            *Build:* <${BUILDKITE_BUILD_URL:-#}|#${BUILDKITE_BUILD_NUMBER:-unknown}>
            *Pipeline:* \`${BUILDKITE_PIPELINE_SLUG:-unknown}\`
            *Branch:* \`${BUILDKITE_BRANCH:-unknown}\`
EOF
        )
        
        echo "$notification_pipeline" | buildkite-agent pipeline upload || echo "‚ö†Ô∏è  Failed to inject Slack notification step"
        echo "‚úÖ Slack notification step injected for $slack_channel"
    else
        echo "‚ÑπÔ∏è  No Slack channel configured - skipping notification"
    fi
}

create_deployment_annotation() {
    local app_name="$1"
    local previous_version="$2"
    local current_version="$3"
    local deployment_result="$4"
    
    local annotation
    case "$deployment_result" in
        "success")
            annotation="‚úÖ **ArgoCD Deployment Successful**

**Application:** \`$app_name\`  
**Previous Version:** \`$previous_version\`  
**Current Version:** \`$current_version\`  
**Status:** \`$deployment_result\`  
**Timestamp:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
            ;;
        "failed")
            annotation="‚ùå **ArgoCD Deployment Failed**

**Application:** \`$app_name\`  
**Status:** \`$deployment_result\`  
**Timestamp:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
            ;;
    esac
    
    local style
    if [[ "$deployment_result" == "success" ]]; then
        style="success"
    else
        style="error"
    fi
    
    buildkite-agent annotate "$annotation" --style "$style" --context "argocd-deployment-$app_name" || true
}

create_rollback_annotation() {
    local app_name="$1"
    local from_revision="$2"
    local to_revision="$3"
    
    local annotation="üîÑ **ArgoCD Rollback**

**Application:** \`$app_name\`  
**Failed Revision:** \`$from_revision\`  
**Rolled Back To:** \`$to_revision\`  
**Build:** [${BUILDKITE_BUILD_NUMBER:-unknown}](${BUILDKITE_BUILD_URL:-#})  
**Pipeline:** \`${BUILDKITE_PIPELINE_SLUG:-unknown}\`  
**Branch:** \`${BUILDKITE_BRANCH:-unknown}\`"
    
    buildkite-agent annotate "$annotation" --style "warning" --context "argocd-rollback-$app_name" || true
}

handle_log_collection_and_artifacts() {
    local app_name="$1"
    local deployment_log_file="$2"
    
    collect_logs=$(plugin_read_config COLLECT_LOGS "false")
    upload_artifacts_enabled=$(plugin_read_config UPLOAD_ARTIFACTS "false")
    log_lines=$(plugin_read_config LOG_LINES "1000")
    
    if [[ "$collect_logs" == "true" ]]; then
        echo "üìã Log collection enabled, gathering ArgoCD application logs..."
        local log_dir
        log_dir=$(collect_app_logs "$app_name" "$log_lines")
        
        # Copy deployment log to the log directory
        if [[ -f "$deployment_log_file" ]]; then
            cp "$deployment_log_file" "$log_dir/"
        fi
        
        if [[ "$upload_artifacts_enabled" == "true" ]]; then
            upload_artifacts "$log_dir" "$app_name"
        else
            echo "üì§ Artifact upload disabled, logs collected in: $log_dir"
        fi
    else
        echo "üìã Log collection disabled"
        
        # Still upload the deployment log if artifacts are enabled
        if [[ "$upload_artifacts_enabled" == "true" && -f "$deployment_log_file" ]]; then
            echo "üì§ Uploading deployment log..."
            buildkite-agent artifact upload "$deployment_log_file" || true
        fi
    fi
}

inject_rollback_decision_block() {
    local app_name="$1"
    local previous_revision="$2"
    
    echo "üìã Injecting rollback decision block step for $app_name..."
    
    # Pre-compute everything while in plugin context (Layer 2)
    local rollback_target
    if [[ -n "$previous_revision" && "$previous_revision" != "unknown" ]]; then
        rollback_target="$previous_revision"
    else
        # Get the current stable deployment that's actually running in the cluster
        rollback_target=$(get_current_stable_deployment "$app_name")
    fi
    
    # Get the ArgoCD history ID NOW while we have plugin functions
    local history_id=""
    if [[ "$rollback_target" != "unknown" ]]; then
        history_id=$(lookup_deployment_history_id "$app_name" "$rollback_target" || echo "")
    fi
    
    # Get connection details NOW
    local server
    local username
    local timeout
    local timestamp
    server=$(plugin_read_config ARGOCD_SERVER "${ARGOCD_SERVER:-}")
    username=$(plugin_read_config ARGOCD_USERNAME "${ARGOCD_USERNAME:-}")
    timeout=$(plugin_read_config TIMEOUT "300")
    
    # Pre-compute timestamp to avoid command substitution in Layer 3
    timestamp=$(date -u '+%Y-%m-%d %H:%M:%S UTC')
    
    # Validate we have what we need for rollback
    if [[ "$rollback_target" == "unknown" || -z "$history_id" ]]; then
        echo "‚ùå Error: Cannot determine rollback target for manual rollback"
        echo "   rollback_target: $rollback_target"
        echo "   history_id: $history_id"
        echo "   This usually means:"
        echo "   - No previous deployment exists"
        echo "   - ArgoCD history lookup failed"
        echo "   - Application has never been successfully deployed"
        echo ""
        echo "   Manual rollback requires a valid previous deployment to rollback to."
        return 1
    fi
    
    echo "‚úÖ Pre-computed rollback: target=$rollback_target, history_id=$history_id"
    
    # Create a temporary file for the pipeline YAML
    local pipeline_file
    pipeline_file=$(mktemp)
    
    # Generate the pipeline YAML with pre-baked values
    cat > "$pipeline_file" << EOF
steps:
  - block: "Deployment Failed - Choose Action"
    key: "deployment-failed-choose-action"
    prompt: |
      **Deployment failed for application: $app_name**
      
      Please choose your next action:
      
      **Option 1: Rollback (Recommended)**
      - Rollback to previous stable deployment
      - Target: $rollback_target
      - Safer option for production environments
      
      **Option 2: Accept Failure**
      - Keep current failed state for debugging
      - Manual investigation required
    fields:
      - select: "Action"
        key: "rollback_decision"
        hint: "What would you like to do?"
        required: true
        default: "rollback"
        options:
          - label: "Rollback to Previous Stable Version"
            value: "rollback"
          - label: "Accept Failure (No Rollback)"
            value: "accept"

  - label: "Execute User Decision"
    depends_on: "deployment-failed-choose-action"
    command: |
      echo "--- Checking user decision from block step"
      
      # Get the user's decision from metadata (this runs AFTER block step completes)
      user_decision=\$(buildkite-agent meta-data get "rollback_decision" --default "")
      echo "User selected: \$user_decision"
      
      if [ "\$user_decision" = "rollback" ]; then
        echo "--- Executing rollback for $app_name"
        echo "Target revision: $rollback_target"
        echo "History ID: $history_id"
        
        # Direct rollback with pre-computed values
        if argocd app rollback "$app_name" "$history_id" --server "$server" --username "$username" --password "\${ARGOCD_PASSWORD}" --timeout "$timeout" --insecure; then
          echo "Rollback completed successfully"
          
          # Create success annotation
          printf "**Manual Rollback Successful**\n\nApplication: %s\nRolled back to: %s\nHistory ID: %s\nTimestamp: %s\n\nThe application has been restored to the previous stable version." \\
            "$app_name" "$rollback_target" "$history_id" "$timestamp" | \\
            buildkite-agent annotate --style "success" --context "manual-rollback-$app_name" || true
            
          # Update metadata
          buildkite-agent meta-data set "deployment:argocd:$app_name:result" "rollback_success"
          buildkite-agent meta-data set "deployment:argocd:$app_name:status" "rolled_back"
          
        else
          echo "Rollback failed"
          
          # Create failure annotation
          printf "**Manual Rollback Failed**\n\nApplication: %s\nTarget: %s\nHistory ID: %s\nTimestamp: %s\n\nManual investigation may be required." \\
            "$app_name" "$rollback_target" "$history_id" "$timestamp" | \\
            buildkite-agent annotate --style "error" --context "manual-rollback-failed-$app_name" || true
            
          # Update metadata
          buildkite-agent meta-data set "deployment:argocd:$app_name:result" "rollback_failed"
          buildkite-agent meta-data set "deployment:argocd:$app_name:status" "rollback_failed"
          
          exit 1
        fi
        
      elif [ "\$user_decision" = "accept" ]; then
        echo "--- User chose to accept deployment failure"
        
        # Create annotation for accepted failure
        printf "**Deployment Failure Accepted**\n\nApplication: %s\nAction: User chose to accept failure and skip rollback\nStatus: Failed deployment left in place for debugging\nTimestamp: %s\n\nManual investigation and cleanup may be required." \\
          "$app_name" "$timestamp" | \\
          buildkite-agent annotate --style "warning" --context "accept-failure-$app_name" || true
        
        # Update metadata
        buildkite-agent meta-data set "deployment:argocd:$app_name:result" "failure_accepted"
        buildkite-agent meta-data set "deployment:argocd:$app_name:status" "failed_accepted"
        
        echo "Failure accepted - no rollback performed"
        
      else
        echo "‚ùå Error: No valid decision found in metadata"
        echo "Expected 'rollback' or 'accept', got: '\$user_decision'"
        echo "Please complete the block step first"
        exit 1
      fi
EOF
    
    echo "üì§ Uploading rollback decision pipeline..."
    local upload_output
    if upload_output=$(buildkite-agent pipeline upload "$pipeline_file" 2>&1); then
        echo "‚úÖ Successfully injected rollback decision steps"
        rm -f "$pipeline_file"
        return 0
    else
        echo "‚ùå Failed to inject rollback decision steps - pipeline upload failed"
        echo "üìã Upload error output:"
        echo "$upload_output"
        echo ""
        echo "üêõ DEBUG: Generated YAML with line numbers for troubleshooting:"
        echo "----------------------------------------"
        cat -n "$pipeline_file" >&2
        echo "----------------------------------------"
        echo ""
        echo "üí° Check for:"
        echo "   - YAML indentation issues"
        echo "   - Special characters in variables"
        echo "   - Missing quotes around values"
        echo "   - Invalid YAML syntax"
        echo ""
        echo "üîç Variables used:"
        echo "   app_name: '$app_name'"
        echo "   rollback_target: '$rollback_target'"
        echo "   history_id: '$history_id'"
        echo "   server: '$server'"
        echo "   username: '$username'"
        echo "   timeout: '$timeout'"
        echo "   timestamp: '$timestamp'"
        rm -f "$pipeline_file"
        return 1
    fi
}

# Execute main function
main "$@"